<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title>Eighties box</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link
      rel="stylesheet"
      type="text/css"
      media="screen"
      href="{{ url_for('static', filename='main.css') }}"
    />
    <script src="{{ url_for('static', filename='dropzone.js') }}"></script>
    <link
      rel="stylesheet"
      href="https://unpkg.com/dropzone@5/dist/min/dropzone.min.css"
      type="text/css"
    />
    <script src="{{ url_for('static', filename='socket.io.min.js') }}"></script>
    <link
      rel="stylesheet"
      href="{{ url_for('static', filename='simplekeyboard.css') }}"
    />
    <style>
      .spinner {
        margin: 100px auto;
        width: 50px;
        height: 50px;
        border: 5px solid #f3f3f3;
        border-top: 5px solid #3498db;
        border-radius: 50%;
        animation: spin 2s linear infinite;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      /* For screen sizes less than 320px */
      @media (max-width: 515px) {
        #game-container {
          max-width: 320px;
          text-align: center;
          margin: auto;
        }
      }

      /* For screen sizes between 321px and 1280px */
      @media (min-width: 321px) and (max-width: 1280px) {
        #game-container {
          max-width: 640px;
          text-align: center;
          margin: auto;
        }
      }

      /* For screen sizes greater than 1280px */
      @media (min-width: 1281px) {
        #game-container {
          max-width: 960px;
          text-align: center;
          margin: auto;
        }
      }

      .spinner-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        z-index: 1000; /* Make sure this is above everything else */
        display: flex;
        justify-content: center;
        align-items: center;
      }
    </style>
  </head>
  <body>
    <script src="{{ url_for('static', filename='phaser.js') }}"></script>
    <script src="{{ url_for('static', filename='main.js') }}"></script>
    <script src="{{ url_for('static', filename='client.js') }}"></script>
    <script src="{{ url_for('static', filename='simplekeyboard.js') }}"></script>

    <div id="loadingSpinner" class="spinner-overlay" style="display: none">
      <div class="spinner"></div>
    </div>
    <div id="fileUploadDiv" style="display: none">
      <button id="toggleButtonFile">Close upload area</button>
      <div id="uploadStatusFile"></div>
      <form
        action="/upload"
        class="dropzone"
        id="uploadFormFile"
        enctype="multipart/form-data"
      >
        <div class="fallback">
          <input name="file" type="file" />
          <button type="submit">Upload</button>
        </div>
      </form>
    </div>
    <div id="ANSIUploadDiv" style="display: none">
      <button id="toggleButtonANSI">Close ANSI Upload</button>
      <div id="uploadStatusANSI"></div>
      <form
        action="/upload"
        class="dropzone"
        id="uploadFormANSI"
        enctype="multipart/form-data"
      >
        <div class="fallback">
          <input name="file" type="file" />
          <button type="submit">Upload</button>
        </div>
      </form>
    </div>
    <div id="game-container"></div>
    <div class="spinner" id="spinner"></div>
    <div
      class="simple-keyboard"
      id="simple-keyboard"
      style="display: none"
    ></div>
    <script>
      const Keyboard = window.SimpleKeyboard.default;
      var uploadToken = "";
      var uploadID = "";
      var current_file_area = "";

      const myKeyboard = new Keyboard({
        layout: {
          default: [
            "^ 1 2 3 4 5 6 7 8 9 0 - = {bksp}",
            "{tab} q w e r t y u i o p ] [ \\",
            "{lock} a s d f g h j k l : ' {enter}",
            "{shift} z x c v b n m , . / {shift}",
            "{escape} @ {space}",
          ],
          shift: [
            "~ ! @ # $ % ^ & * ( ) _ + {bksp}",
            "{tab} Q W E R T Y U I O P { } |",
            '{lock} A S D F G H J K L : " {enter}',
            "{shift} Z X C V B N M < > ? {shift}",
            "{escape} @ {space}",
          ],
        },
        onKeyPress: (button) => onKeyPress(button),
      });

      function onKeyPress(button) {
        if (button === "{shift}" || button === "{lock}") handleShift();

        const buttonMap = {
          "{tab}": "Tab",
          "{bksp}": "Backspace",
          "{enter}": "Enter",
          "{space}": " ",
          "{escape}": "Escape",
          ">": "ArrowDown",
          "<": "ArrowUp",
        };
        var readableButton = buttonMap[button] || button;
        handleKeyCode(readableButton);
      }

      function handleShift() {
        const currentLayout = myKeyboard.options.layoutName;
        const shiftToggle = currentLayout === "default" ? "shift" : "default";

        myKeyboard.setOptions({
          layoutName: shiftToggle,
        });
      }

      function generateUUID() {
        return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, (c) =>
          (
            c ^
            (crypto.getRandomValues(new Uint8Array(1))[0] & (15 >> (c / 4)))
          ).toString(16)
        );
      }

      function addClickListeners() {
        const toggleButtonFile = document.getElementById("toggleButtonFile");
        const fileUploadDiv = document.getElementById("fileUploadDiv");

        toggleButtonFile.addEventListener("click", function () {
          socket.emit("upload_finished", {});
          fileUploadDiv.style.display = "none";
          const canvasElements = document.getElementsByTagName("canvas");
          for (let i = 0; i < canvasElements.length; i++) {
            canvasElements[i].style.display = "inline";
          }
        });
        const toggleButtonANSI = document.getElementById("toggleButtonANSI");
        const ANSIUploadDiv = document.getElementById("ANSIUploadDiv");

        toggleButtonANSI.addEventListener("click", function () {
          ANSIUploadDiv.style.display = "none";
          const canvasElements = document.getElementsByTagName("canvas");
          for (let i = 0; i < canvasElements.length; i++) {
            canvasElements[i].style.display = "inline";
          }
        });
      }

      document.addEventListener("DOMContentLoaded", function () {
        setTimeout(function () {
          const canvasElements = document.getElementsByTagName("canvas");
          for (let i = 0; i < canvasElements.length; i++) {
            canvasElements[i].addEventListener("click", function () {
              window.open("https://github.com/asciibox/eightiesbox", "_blank");
            });
            canvasElements[i].addEventListener("touchend", function () {
              window.open("https://github.com/asciibox/eightiesbox", "_blank");
            });
          }
        }, 2000);

        addClickListeners();
      });

      Dropzone.options.uploadFormFile = {
        maxFilesize: 1000, // MB
        maxFiles: 1,
        url: "https://storage.googleapis.com", // Default URL
        method: "POST",
        createImageThumbnails: true,
        processData: false, // Don't process data
        init: function () {
          var myDropzone = this;
          var uploadUrl; // Variable to hold the upload URL

          // Function to add hidden input to form
          function addHiddenInput(name, value) {
            var input = document.createElement("input");
            input.setAttribute("type", "hidden");
            input.setAttribute("name", name);
            input.setAttribute("value", value);
            myDropzone.element.appendChild(input);
          }

          // Function to remove all hidden inputs
          function removeAllHiddenInputs() {
            var hiddenInputs =
              myDropzone.element.querySelectorAll("input[type=hidden]");
            hiddenInputs.forEach(function (input) {
              input.remove();
            });
          }

          this.on("processing", (file) => {
            myDropzone.options.headers = {
              "Content-Type": file.type,
            };
            myDropzone.options.url = uploadUrl;
          });

          this.on("addedfile", function (file) {
            if (this.files.length > 1) {
              this.removeFile(this.files[0]); // Remove the earlier file
            }
            // Fetch the signed URL and other parameters
            uploadID = generateUUID();
            fetch(
              "/getSignedUrl?filename=" +
                file.name +
                "&filesize=" +
                file.size +
                "&uploadToken=" +
                uploadToken +
                "&current_file_area=" +
                current_file_area +
                "&uploadID=" +
                uploadID,
              {
                method: "GET",
              }
            )
              .then((response) => response.json())
              .then((data) => {
                addHiddenInput("policy", data.policy);
                addHiddenInput("signature", data.signature);
                addHiddenInput("GoogleAccessId", data.GoogleAccessId);
                addHiddenInput("bucket", data.bucket);
                addHiddenInput("key", data.key);
                uploadUrl = `https://storage.googleapis.com/upload/storage/v1/b/eightiesbox/o?uploadType=media&name=${data.key}`;
                myDropzone.processFile(file);
              });
          });

          this.on("sending", function (file, xhr) {
            var _send = xhr.send;
            xhr.send = function () {
              _send.call(xhr, file);
            };
          });

          this.on("success", function (file, response) {
            document.getElementById(
              "uploadStatusFile"
            ).innerHTML += `<div>File ${file.name} uploaded successfully</div>`;

            document.getElementById("loadingSpinner").style.display = "inline"; // Hide spinner
            setTimeout(function () {
              checkUploadStatus(uploadID);
            }, 750);
          });

          this.on("error", function (file, response) {
            document.getElementById(
              "uploadStatusFile"
            ).innerHTML += `<div>Failed to upload ${file.name}</div>`;
          });
        },
      };

      async function checkUploadStatus(uploadID, attempts = 1) {
        try {
          const response = await fetch("/checkUpload?uploadID=" + uploadID, {
            method: "GET",
          });
          const data = await response.json();

          if (data.success === true || attempts >= 10) {
            // If success is true or attempts are 10 or more, handle the success case
            console.log("Success or maximum attempts reached:", data);
            document.getElementById("loadingSpinner").style.display = "none"; // Hide spinner
            return data; // You might want to do something with this data
          } else {
            // If success is not true and attempts are less than 10, retry after a delay
            console.log(
              "Attempt number " + attempts + " unsuccessful, retrying..."
            );
            setTimeout(
              () => checkUploadStatus(uploadID, attempts + 1),
              attempts < 4 ? 750 : 2000
            ); // wait for 2 seconds before retrying
          }
        } catch (error) {
          console.error("Error occurred:", error);
          if (attempts < 10) {
            setTimeout(() => checkUploadStatus(uploadID, attempts + 1), 2000);
          } else {
            console.error("Maximum attempts reached. Stopping retries.");
          }
        }
      }

      Dropzone.options.uploadFormANSI = {
        maxFilesize: 1, // MB
        autoProcessQueue: true, // TODO: Check
        init: function () {
          this.on("addedfile", function (file) {
            // Create a FileReader object
            var reader = new FileReader();

            // You can access the filename here
            var filename = file.name;

            // Read the file as Data URL (Base64)
            reader.readAsDataURL(file);

            // Event handler when the reading is complete
            reader.onload = function (event) {
              // Get the Base64 string, remove the Data URL prefix
              var base64String = event.target.result.split(",")[1];

              var xhr = new XMLHttpRequest();
              xhr.open("POST", "/upload", true);
              xhr.setRequestHeader("Content-Type", "application/json");

              xhr.onreadystatechange = function () {
                if (xhr.readyState == 4 && xhr.status == 200) {
                  document.getElementById(
                    "uploadStatusANSI"
                  ).innerHTML += `<div>File ${filename} uploaded successfully</div>`;
                }
              };

              // Include the filename in the JSON payload
              xhr.send(
                JSON.stringify({
                  file_data: base64String,
                  filename: filename, // Add filename here
                })
              );
            };
          });

          this.on("success", function (file, response) {
            document.getElementById(
              "uploadStatusANSI"
            ).innerHTML += `<div>File ${file.name} uploaded successfully</div>`;
          });

          this.on("error", function (file, response) {
            document.getElementById(
              "uploadStatusANSI"
            ).innerHTML += `<div>Failed to upload ${file.name}</div>`;
          });
        },
      };

      socket.on("uploadFile", (data) => {
        const canvasElements = document.getElementsByTagName("canvas");
        for (let i = 0; i < canvasElements.length; i++) {
          canvasElements[i].style.display = "none";
        }

        const uploadDiv = document.getElementById("fileUploadDiv");
        uploadDiv.style.display = "inline";
      });
      socket.on("uploadANSI", (data) => {
        const canvasElements = document.getElementsByTagName("canvas");
        for (let i = 0; i < canvasElements.length; i++) {
          canvasElements[i].style.display = "none";
        }

        const ANSIUploadDiv = document.getElementById("ANSIUploadDiv");
        ANSIUploadDiv.style.display = "inline";
      });
    </script>
  </body>
</html>
